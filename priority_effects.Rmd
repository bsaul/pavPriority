---
title: "Priority Effects"
output: pdf_document
---

Consider the following graph:

![Basic DAG](figures/dag1.jpg)

$A_0$ is the manipulable intervention delivered at time 0. $Y_1$ is the outcome observed at time 1, and $Y_2$ is the same outcome observed at time 2. The objective is to learn not only about the effect of $A_0$ on $Y_1$, but also about the effect of $Y_1$ on $Y_2$. This objective falls -- to varying degrees -- under mediation, principle stratification, and structural equation models.

*Question*: How to represent this problem in counterfactuals? Most counterfactual analysis (that I'm familiar with) is interested in the effect of a treatment, but here the interest is the causal effects of treatment *and* in the distributional relationships between variables downstream of the treatment. 

![Possible SWITs showing counterfactual relationships. (1) is the typical SWIT. Are (2), (3), and (4) possible SWITs?](figures/swit2.jpg)

## An approach

Suppose the following structual model:

\begin{align*}
\label{causal_model}
y_1(a_0) &= y_1(0) + \theta a_0 \\
y_2(y_1(a_0)) &= y_2(y_1(a_0 = 0)) + \delta y_1(a_0) \\
\end{align*}

???


```{r setup, echo= FALSE, eval=FALSE}
#------------------------------------------------------------------------------#
# A simple simulator to test a not-so-simple idea
#------------------------------------------------------------------------------#

library(dplyr)
library(tidyr)
library(ggplot2)

#------------------------------------------------------------------------------#
# Causal model functions ####
#------------------------------------------------------------------------------#

generate_obs <- function(n, y10, y20, a0, theta, delta){
  data_frame(
    a0 = a0,
    y1 = y10 + theta * a0,
    y2 = y20 + delta * y1
  )
}

causal_model <- function(data, theta_hyp, delta_hyp){
  data %>% mutate_(
    y1_o =~ y1 - theta_hyp * a0,
    y2_o =~ y2 - delta_hyp * y1
  )
}

# from: https://stackoverflow.com/questions/28368072/create-combinations-of-a-binary-vector
make_Omega <- function(n, m) {
  ind <- combn(seq_len(n), m)
  ind <- t(ind) + (seq_len(ncol(ind)) - 1) * n
  res <- rep(0, nrow(ind) * n)
  res[ind] <- 1
  matrix(res, ncol = n, nrow = nrow(ind), byrow = TRUE)
}

pval1 <- function(O, a, z){
  ts_obs <- as.numeric(t(a) %*% z)
  ts_dist <- as.numeric(O %*% z)
  mean(abs(ts_obs) <= abs(ts_dist))
}

pval2 <- function(z, y){
  cor.test(z, y, exact = TRUE)$p.value
}

pval3 <- function(O, a, z){
  obs <- cov(a, z)
  dist <- apply(O, 1, function(x) cov(x, a))
  mean(abs(obs) <= abs(dist))
}

overall_pval <- function(p){
  ts <- -2 * sum(log(p))
  pchisq(ts, df = 2 * 2, lower.tail = FALSE)
}
```

```{r, echo = FALSE, eval = FALSE}
n <- 10
Omega <- make_Omega(n, n/2) 
```


```{r, echo = FALSE}
tester <- function(obs_data, O, delta_hyp, theta_hyp){

   new_data <- causal_model(obs_data, delta_hyp, theta_hyp)
  
  ## Method 1 ##
   p1 <- pval1(O, new_data$a0, new_data$y1_o)
   p2 <- pval2(new_data$y1_o, new_data$y2_o)
   method1_p <- overall_pval(c(p1, p2))
   
  ## Method 2 ##
   p1 <- pval2(new_data$a0, new_data$y1_o)
   p2 <- pval2(new_data$y1_o, new_data$y2_o)
   method2_p <- overall_pval(c(p1, p2))
   
  ## Method 3 ##
   p1 <- pval3(O, new_data$a0, new_data$y1_o)
   p2 <- pval2(new_data$y1_o, new_data$y2_o)
   method3_p <- overall_pval(c(p1, p2))
    
  c(
    method1 = method1_p,
    method2 = method2_p,
    method3 = method3_p
  )
}

simulator <- function(seed, O){
  set.seed(seed)
  n <- ncol(O)
  y1 <- runif(n)
  y2 <- runif(n)  
  a_obs <- O[sample(nrow(O), 1), ]
  generate_obs(n, y1, y2, a_obs, 1, 1)
}

simulate_and_test <- function(seed, O, hypotheses){
  obs_data <- simulator(seed, O)
  
  apply(hypotheses, 1, function(x){
    tester(obs_data, O, theta_hyp = x[1], delta_hyp = x[2])
  }) %>% t %>% cbind(hypotheses)
}
```

```{r, eval = FALSE, echo = FALSE}
hypotheses <- expand.grid(theta = seq(-1, 3, by = .1), delta = seq(-1, 3, by = .1))


test <- lapply(1:100, function(seed){
  simulate_and_test(seed, Omega, hypotheses) %>%
    mutate_(simID =~ seed)
})

test2 <- test %>%
  bind_rows() %>% tidyr::gather(method, val, -theta, -delta, -simID) %>%
  group_by(method, theta, delta) %>%
  summarise(power = mean(val <= 0.05))

```

```{r plots, echo = FALSE, eval = FALSE}
ggplot(
  data = test2,
  aes(x = theta, y = delta)
) + geom_point(aes(fill = power), shape = 21, color = 'white') +
  scale_fill_gradient(low = 'red', high = 'white') + 
  theme_classic() + 
  facet_grid(~method)
```
